# 选取样本（Selection Sampling）

目标：从*n*个项的集合中随机选择*k*个项。

假设你有一副52张牌，你需要随机抽取10张牌。 这个算法可以让你达成。

这是一个非常快的版本：

```swift
func select<T>(from a: [T], count k: Int) -> [T] {
  var a = a
  for i in 0..<k {
    let r = random(min: i, max: a.count - 1)
    if i != r {
      swap(&a[i], &a[r])
    }
  }
  return Array(a[0..<k])
}
```

正如[洗牌算法](../Shuffle/)经常发生的那样，它将数组划分为两个区域。 第一个区域包含所选项; 第二个区域是所有剩余的项。

一个例子。 假设一个数组是：

	[ "a", "b", "c", "d", "e", "f", "g" ]
	
我们想选择3个项目，所以`k = 3`。 在循环中，`i`最初为0，因此它指向`"a"`。

	[ "a", "b", "c", "d", "e", "f", "g" ]
	   i

我们计算`i`和数组的大小`a.count`之间的随机数。 假设这个随机数是4。 现在我们将`"a"`与索引为4的`"e"`交换，然后向前移动`i`：

	[ "e" | "b", "c", "d", "a", "f", "g" ]
	         i

`|`栏表示两个区域之间的分割。 `"e"`是我们选择的第一个元素。 我们继续需要关注`|`栏右侧的所有内容。

再一次，我们要求`i`和`a.count`之间的随机数，但因为`i`已经移位，随机数永远不会小于1。所以我们再也不会交换`"e"`了。

假设随机数为6，我们将`"b"`与`"g"`交换：

	[ "e" , "g" | "c", "d", "a", "f", "b" ]
	               i

还有一个随机数，假设它是4。 我们将`"c"`与`"a"`交换，最终左边已经选择的项为：

	[ "e", "g", "a" | "d", "c", "f", "b" ]

就是这样。 十分简单。 这个函数的性能是**O(k)**，因为只要我们选择了*k*元素，就结束了。

下面是一种替代算法，称为“水库抽样”(Reservoir Sampling)：

```swift
func reservoirSample<T>(from a: [T], count k: Int) -> [T] {
  precondition(a.count >= k)

  var result = [T]()      // 1
  for i in 0..<k {
    result.append(a[i])
  }

  for i in k..<a.count {  // 2
    let j = random(min: 0, max: i)
    if j < k {
      result[j] = a[i]
    }
  }
  return result
}
```

有两个步骤：


1. 使用原始数组中的第一个`k`元素填充`result`数组。 这被称为“水库”。
2. 用剩余池中的元素随机替换水库中的元素。

该算法的性能为 **O(n)**，因此它比第一算法慢一点。但是，它的最大优点是它可以用于太大而无法容纳在内存中的数组，即使你不知道数组的大小是多少（在Swift中这可能类似于读取文件元素的懒惰生成器）。

前两种算法有一个缺点：它们不保留原始顺序的元素。在输入数组中，`"a"`出现在`"e"`之前，但现在却是另一种顺序。如果要顺序不变，则无法使用上面的方法。

下面这种替代方法，可以保持原始顺序的完整性，但需要更多空间参与：

```swift
func select<T>(from a: [T], count requested: Int) -> [T] {
  var examined = 0
  var selected = 0
  var b = [T]()
  
  while selected < requested {                          // 1
    let r = Double(arc4random()) / 0x100000000          // 2
    
    let leftToExamine = a.count - examined              // 3
    let leftToAdd = requested - selected

    if Double(leftToExamine) * r < Double(leftToAdd) {  // 4
      selected += 1
      b.append(a[examined])
    }

    examined += 1
  }
  return b
}
```

该算法使用概率来决定是否在选择中包括一个数字。


1. 循环从头到尾逐步完成数组。 它一直持续到我们从*n*的集合中选择*k*个项。 这里，*k*是`requested`而*n*是`a.count`。

2. 计算0到1之间的随机数。我们想要`0.0 <= r < 1.0`。 上限是排他性的; 我们从不希望它是1。这就是为什么我们将结果从`arc4random()`除以`0x100000000`而不是更常见的`0xffffffff`。
 
3. `leftToExamine`是我们还没有看过的项数目。 `leftToAdd`是我们在完成之前还需要选择的项数。

4. 这就是魔术发生的地方。 基本上，我们正在翻转一枚硬币。 如果是heads，我们将当前数组元素添加到选择中; 如果是tails，我们就跳过。

有趣的是，即使我们使用概率，这种方法总是保证我们最终得到输出数组中的*k*项。

让我们再次讨论相同的例子。 输入数组是：

	[ "a", "b", "c", "d", "e", "f", "g" ]

循环依次查看每个元素，因此我们从`"a"`开始。 我们得到一个介于0和1之间的随机数，假设它是0.841。 `// 4`处的公式将要检查的项目数乘以此随机数。 还有7个元素需要检查，结果是：

	7 * 0.841 = 5.887

我们将此与3进行比较，因为我们想要选择3个项目。 由于5.887大于3，我们跳过`"a"`并继续移动动`"b"`。

再一次，我们得到一个随机数，比方说0.212。 现在只剩下6个要检查的元素，因此公式结果是：

	6 * 0.212 = 1.272

小于3，我们在选择中添加`"b"`。 这是我们选择的第一个项，所以还剩下两个。

到下一个元素，`"c"`。 随机数为0.264，得出结果：

	5 * 0.264 = 1.32

只要再选择2个项，因此这个数字必须小于2。它是，我们还在选择中加入`"c"`。 总选择是`["b"，"c"]`。

只要再选择1个项，但仍有4个候选项要查看。 假设下一个随机数是0.718。 该公式现在给出：

	4 * 0.718 = 2.872

要选择此元素，数字必须小于1，因为只剩下1个项要选择。 2.872不是，所以我们跳过`"d"`。 只剩下三种可能性 - 我们会在耗尽元素之前选到它吗？

随机数为0.346。 该公式给出：

	3 * 0.346 = 1.038
	
有点太高了。 我们跳过`"e"`。 只有两名候选项了......

请注意，现在字面上我们正在处理抛硬币：如果随机数小于0.5，我们选择`"f"`，我们就完成了。 如果它大于0.5，我们继续最后的元素。 假设我们得到0.583：

	2 * 0.583 = 1.166

我们跳过`"f"`并查看最后一个元素。 无论我们在这里得到什么随机数，它应该总是选择`"g"`或者我们不会选择足够的元素而算法不起作用！

假设我们的最终随机数是0.999（记住，它永远不会是1.0或更高）。 实际上，无论我们在这里选择什么，公式总是会给出小于1的值：

	1 * 0.999 = 0.999

因此，如果我们还没有足够多的选择，那么总是会选择最后一个元素。最后的选择是`[ "b", "c", "g" ]`。请注意，元素仍处于原始顺序，因为我们是从左到右查询数组。

也许你还不相信......如果我们总是将0.999作为随机值（最大可能值），那还能选择3项吗？ 好吧，让我们做数学：

	7 * 0.999 = 6.993     小于3吗? no
	6 * 0.999 = 5.994     小于3吗? no
	5 * 0.999 = 4.995     小于3吗? no
	4 * 0.999 = 3.996     小于3吗? no
	3 * 0.999 = 2.997     小于3吗? YES
	2 * 0.999 = 1.998     小于2吗? YES
	1 * 0.999 = 0.999     小于1吗? YES

它总是有效！ 但这是否意味着靠近数组末尾的元素比一开始的元素更有可能被选中？ 不，所有元素同样可能被选中。 （如果不相信我的话：在playground 看一下快速测试，在实践中证明了这一点。）

以下是如何测试此算法的示例：

```swift
let input = [
  "there", "once", "was", "a", "man", "from", "nantucket",
  "who", "kept", "all", "of", "his", "cash", "in", "a", "bucket",
  "his", "daughter", "named", "nan",
  "ran", "off", "with", "a", "man",
  "and", "as", "for", "the", "bucket", "nan", "took", "it",
]

let output = select(from: input, count: 10)
print(output)
print(output.count)
```

第二种算法的性能是**O(n)**，因为它可能需要遍历整个输入数组。

> **注意：** 如果`k > n / 2`，那么以相反的方式执行它并选择要删除的`a.count - k`项更有效。

代码基于发表于1993年10月Dobb博士的杂志的Algorithm Alley。

<br>

*作者：Matthijs Hollemans*  
*翻译：[Andy Ron](https://github.com/andyRon)*  
*校对：[Andy Ron](https://github.com/andyRon)*  